use duckdb::Connection;

/// Result of a sequence match query.
#[derive(Debug, Clone, serde::Serialize)]
pub struct SequenceMatchResult {
    pub converting_visitors: u64,
    pub total_visitors: u64,
    pub conversion_rate: f64,
}

/// Build a sequence_match pattern from numbered conditions.
///
/// Generates `(?1).*(?2).*...(?N)` for the given number of conditions.
fn build_pattern(num_conditions: usize) -> String {
    (1..=num_conditions)
        .map(|i| format!("(?{i})"))
        .collect::<Vec<_>>()
        .join(".*")
}

/// Build the sequence_match SQL query.
///
/// `conditions` are safe SQL boolean expressions (e.g., `pathname = '/pricing'`).
fn build_sequence_match_sql(conditions: &[&str]) -> String {
    let pattern = build_pattern(conditions.len());
    let conds = conditions.join(", ");
    format!(
        "SELECT
            COUNT(*) FILTER (WHERE matched) AS converting_visitors,
            COUNT(*) AS total_visitors,
            COALESCE(COUNT(*) FILTER (WHERE matched)::FLOAT / NULLIF(COUNT(*), 0), 0) AS conversion_rate
         FROM (
             SELECT visitor_id,
                 sequence_match('{pattern}', timestamp, {conds}) AS matched
             FROM events
             WHERE site_id = ? AND timestamp >= CAST(? AS TIMESTAMP) AND timestamp < CAST(? AS TIMESTAMP)
             GROUP BY visitor_id
         )"
    )
}

/// Execute a sequence match query and return results.
///
/// `conditions` must be safe SQL boolean expressions generated by the API layer
/// (e.g., `pathname = '/pricing'`, `event_name = 'signup'`).
/// Requires the behavioral extension to be loaded.
pub fn execute_sequence_match(
    conn: &Connection,
    site_id: &str,
    start_date: &str,
    end_date: &str,
    conditions: &[&str],
) -> Result<SequenceMatchResult, duckdb::Error> {
    if conditions.is_empty() {
        return Ok(SequenceMatchResult {
            converting_visitors: 0,
            total_visitors: 0,
            conversion_rate: 0.0,
        });
    }

    let sql = build_sequence_match_sql(conditions);
    let mut stmt = conn.prepare(&sql)?;
    stmt.query_row(duckdb::params![site_id, start_date, end_date], |row| {
        Ok(SequenceMatchResult {
            converting_visitors: row.get(0)?,
            total_visitors: row.get(1)?,
            conversion_rate: row.get(2)?,
        })
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_build_sequence_match_sql() {
        let sql = build_sequence_match_sql(&["pathname = '/pricing'", "event_name = 'signup'"]);
        assert!(sql.contains("sequence_match("));
        assert!(sql.contains("(?1).*(?2)"));
        assert!(sql.contains("pathname = '/pricing'"));
        assert!(sql.contains("event_name = 'signup'"));
    }

    #[test]
    fn test_build_pattern() {
        assert_eq!(build_pattern(1), "(?1)");
        assert_eq!(build_pattern(2), "(?1).*(?2)");
        assert_eq!(build_pattern(3), "(?1).*(?2).*(?3)");
    }

    #[test]
    fn test_execute_empty_conditions() {
        let conn = Connection::open_in_memory().unwrap();
        crate::storage::schema::init_schema(&conn).unwrap();
        let result =
            execute_sequence_match(&conn, "test.com", "2024-01-01", "2024-02-01", &[]).unwrap();
        assert_eq!(result.converting_visitors, 0);
        assert_eq!(result.total_visitors, 0);
    }

    #[test]
    fn test_execute_sequence_match_no_extension() {
        let conn = Connection::open_in_memory().unwrap();
        crate::storage::schema::init_schema(&conn).unwrap();
        // Without behavioral extension, this will fail â€” expected behavior
        let result = execute_sequence_match(
            &conn,
            "test.com",
            "2024-01-01",
            "2024-02-01",
            &["pathname = '/'", "event_name = 'signup'"],
        );
        // Graceful: the caller wraps this in unwrap_or
        assert!(result.is_err() || result.unwrap().total_visitors == 0);
    }
}
